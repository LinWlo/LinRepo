# python基础
## 1. python虚拟环境
### 1.1. 虚拟环境的作用
- 隔离每个项目所需要的不同的依赖，避免由于不同的项目需要不同的依赖库版本而造成的冲突情况。
### 1.2. 创建虚拟环境
#### 1.2.1. 命令行创建
- **主流的虚拟环境管理包**：`virtualenv`和`pipenv`
  - 安装`virtualenv`：`pip install virtualenv`
  - 创建虚拟环境：`virtualenv [-p 解释器路径] 路径`
    - `-p`可选的，指定python解释器版本
  - 切换为虚拟环境：
    - 进入虚拟环境路径中的`Script`中，运行`activate.bat`
    - 退出虚拟环境：运行`deactivate.bat`
- **virtualenvwrapper**：virtualenv虚拟环境管理工具的一个辅助包。
  - 安装：`pip install virtualenvwrapper`
    - `wornon`命令不能用时，安装`pip install virtualenvwrapper-win`
  - 作用：简化virtualenv的操作，可以在任意路径操作虚拟环境。
  - 主要命令：
    - `workon`:显示当前已配置的虚拟环境列表
      - 需要配置环境变量：新建变量`WORKON_HOME`,值为虚拟环境路径。
    - `workon 虚拟环境名`:进入指定的虚拟环境。
      - powershell进入失败时，换cmd
    - `mkvirtualenv 虚拟环境名`：创建虚拟环境。
#### 1.2.2. pycharm创建
- 新建项目时，选择Virtualenv新建环境。

## 2. python2和python3的一些区别
- **print**
  - python2中是一个语句
  - python3中是一个函数(可以接收参数)；
- **字符编码**
  - python2中默认编码格式ASCII，不支持中文，需要在开头通过`#coding:utf8`才行；
  - python3默认为`utf8`。不需要再开头指定；
- **input**
  - python2中会根据输入的数据类型返回相应数据类型的值，输入数字返回数字，输入字符串必须加双引号，否则会以变量的形式返回。
  - python3中输入数据全部以字符串返回。
- **除法**
  - python2同c语言一样，两个整数的运算结果只能是整数，存在结果有小数部分直接丢弃。如`1/2=0`,要得到正确的值需要用浮点数计算`1.0/2=0.5`;
  - python3中整数除法保留小数部分。
## 3. 标识符、变量和对象
### 3.1. 标识符

-   **什么是标识符？**
    -   对变量名、函数名、类名、方法名的统称
-   **命令规范**
    -   只能包含字母、数字、下划线（用中文在任何位置也不会报错，但一般不用中文）
    -   不能以数字开头
    -   严格区分大小写
    -   不能与系统关键字相同
        -   在python中导入：`import keyword`
        -   输入：keyword.kwlist 即可看到系统关键字
    -   尽量不与系统的内置函数、模块名相同
    -   尽量使用有意义的英文单词，多个单词之间使用下划线连接
### 3.2. 变量的声明

-   如：**`student_name = "zhangsan"`**
    -   后续可以直接重新赋值` student_name = 1000`
-   如：**a,b = 10,20** （表示声明两个变量a,b，值分别为10，20）
    -   **a,b = b,a** （表示将a,b两个变量的值进行了交换，a = 20 b = 10）
-   如：**c = 10,20,30** （会将三个值打包为元组（tuple）类型赋给c变量））
-   当我们赋值时，如`a = "hello"` ，python解释器做了两件事：
    -   在内存中创建了一个`"hello"`的字符串对象；
    -   在内存中创建了一个名为`a`的变量，并把它指向`"hello"` 。
-   **声明变量时会在内存里面开辟一块空间来保存变量名（栈内存），也会开辟一块空间来保存值（对象）（堆内存），并将变量指向该对象（值）。**
    -   在python中，类型属于对象，变量是没有类型的。
    -   如`a=[1,2,3]` `a="Runoob"` ，`[1,2,3]` 是 List 类型，`"Runoob"` 是 String 类型，而变量 a 是没有类型，它仅仅是一个对象的引用(一个指针)，可以是 List 类型对象，也可以指向 String 类型对象。
-   赋值的时候是把值在内存空间中的地址给到这个变量。也就是说变量里面保存的不是这个值，而是这个值在内存空间中的地址。
-   假如已有变量 a = 20，再声明变量 b = 20，此时系统会去内存里面找到已有的20这个值，并把20这个值的内存地址给到b，而不会去重新开辟一块内存地址。也就是说此时 a和b是指向同一个内存地址的(即id(a) = id(b))。此时 a is b 为True a == b 为True
### 3.3. 对象

-   **Python中的一切都是对象。变量是对对象的引用！**（对象是一个抽象，可想象成现实中的一个实际物体）
-   **对象的本质是**：对象是分配的一块内存，有足够的空间去表示它们所代表的值。或者说，一块内存空间，拥有特定的值，支持指定类型的相关操作。
-   **对象的特点**：`标识(identity)`、`类型(type)`、`值(value)`
    -   `标识(identity)`：用于唯一标识对象，通常对应对象在计算机内存中的地址。使用内置函数`id(obj)`返回对象唯一标识。
    -   `类型(type)`：对象中含有标准的头部信息，类型标识符。标识对象类型，表示对象存储的数据的类型。类型可以限制对象的取值范围和可执行的操作。使用内置函数`type(obj)`返回对象所属类型。
        -   每个对象都有两个标准的头部信息：
            1.  类型标识符，去标识对象的数据类型；
            2.  引用计数器，记录当前对象的引用的数目。（回收机制：变量的引用计数器为0，自动清理。较小整数型对象有缓存机制。）
    -   `值(value)` ：表示对象存储的数据的信息。使用内置函数`print(obj)` 可以直接打印值。
-   **`is`和`==`&#x20;**
    -   区别
        -   `is` ：判断两个变量是否指向同一个对象，比较两个引用是否代表了内存中同一个地址，是否指向同一块内存空间。通过`id(obj)` 返回值判断。
        -   `==` ：比较对象的本身内容【类型(type)】和【值(value)】是否一致。默认会调用`__eq__` 方法。
    -   关系
        -   当`id(obj)`相同是，`is`为True，两者的`type` 和`value` 肯定相同，`==` 也为True。
        -   但是当两者的`type` 和`value` 相同时，`==` 为True，两者的`id(obj)` 不一定相同。
            ```python
            >>> a = [1,2]
            >>> b = [1,2]
            >>> a == b
            True
            >>> a is b
            False
            >>>
            >>> c = 257
            >>> d = 257
            >>> c == d
            True
            >>> c is d
            False

            ```
-   **小整数 small\_ints 和 短字符串 缓存池**
    -   CPython(c语言实现的python解释器)出于性能优化的考虑，把频繁使用的整数对象用一个`small_ints`的对象池缓存起来。`small_ints` 缓存的整数值被设定为\[-5,256]这个区间。
    -   如果使用CPython解释器，在任何引用这些整数的地方，都不需要重新创建int对象，而是直接引用缓存池中的对象。
    -   **如果整数不在该范围内，那么即便两个整数的值相同，它们也是不同的对象。**
        ```python
        # 小整数
        >>> a = 256
        >>> b = 256
        >>> a is b
        True
        # 短字符串
        >>> a = 'good'
        >>> b = 'good'
        >>> a is b
        True

        >>> c = 'very good'
        >>> d = 'very good'
        >>> c is d
        False


        ```

## 4. 输入与输出
### 4.1. 注释
- **单行注释**：`#` 或`ctrl + /`
- **多行注释**：三对引号（单引号`''' '''` 或双引号`""" """` 都行）
  - 注：若这三对引号放在等号`=`右边，表示的是字符串，而不是注释
### 4.2. 输入
- **输入**：`input(msg)`
  - 用于接收外部输入，阻塞式的，程序运行到input语句时会暂停，直到按下回车键后继续执行下面的代码；
	- msg：可选的，用于对输入的提示；
	- 无论外部输入的内容是什么，input函数都作为字符串处理；
		- 如 username = input("请输入用户名：")；
		- 无论输入数字，字符串，布尔值，列表等 print(type(username)) 类型都为 str(字符串),相当于在外面加上引号。
- 查看函数或者类的源码
	- `ctrl + 鼠标点击`
### 4.3. 输出
- **输出**：`print(obj1,obj2,sep='',end='\n',file=sys.studout)`
	- 用于输出指定内容;
	- `obj1`,`obj2`：待输出的对象，多个对象之间逗号隔开;
	- `sep=''`：指定多个对象输出结果中的分割符，默认是空格，可以任意指定;
	- `end='\n'`：指定输出完成后的结束符，默认'\n'，即换行;
    - `file=sys.stdout`：将内容输出到文件。
    ```python
    username = input("请输入用户名：") #声明变量，接收外部输入
    password = input("请输入密码：")
    print("账号：",username,"密码：",password)           #输出 账号： user 密码： 123456   每个值与值之间默认有空格
    print("账号：",username,"密码：",password,sep='',end='')    #输出 账号：user密码：123465      每个值与值之间指定分割符为空;结束符为空
    print("账号：",username,"密码：",password,sep='**',end='')  #输出 账号：**user**密码：**123456      每个值与值之间指定分割符为**
    ```

## 5. 数据类型
### 5.1. 字符串
#### 5.1.1. 字符串的创建

-   包含在引号之间的内容，不可变数据类型。
    -   使用单引号或双引号来创建字符串，使用三引号创建多行字符串。
    -   字符串要么使用两个单引号，要么两个双引号，不能一单一双！
    -   Python不支持单字符类型(C或者类似语言的Char类型)，单字符在Python中也是作为一个字符串使用。
-   如果一个字符串内部要有引号，那么最好和外部包裹的引号类型不同。
    -   外层使用单引号，那么里层使用双引号
    -   外层使用双引号，那么里层使用单引号
    -   如果要使用一样的符号呢，那字符串里的引号前记得加转义符号：`\`
        ```python
        >>> msg = 'what\'s you name'
        >>> msg
        "what's you name"
        ```
#### 5.1.2. 字符串元素的访问
- 通过索引访问到字符串中的指定的元素。
-   `字符串[索引]`
-   索引从0开始，从左往右，第一个位置的索引为0，以此类推。
-   索引可以为负数，从右往左，最后一个位置为-1，以此类推。
#### 5.1.3. 字符串格式化
-   **占位符**
    -   语法：`%[-w.p]type %(value)`
        -   `[-w.p]`：可选的，- 表示左对齐(默认为右对齐)，w 表示宽度，.p 表示精度（只能用于浮点型数据）。
        -   `type`：表示数据类型，常用的有`d` 表示`int型`，`f` 表示`浮点型`，`s` 表示`字符串`。
        -   `value`：待输出的内容（变量名），多个value用逗号隔开。
            ```python
            >>> age = 20
            >>> "年龄为：%s" %(age)
            '年龄为：20'
            ```
-   **format**
    -   语法：`'{:w.pf}'.format(value)`
        -   `:w.pf`：可选的，w 表示宽度。.pf 针对浮点型表示精度；
        -   默认靠左对齐，冒号后加>，靠右对齐；加^，居中对齐；
        -   `value`：待输出的内容（变量名），多个value用逗号隔开；
        -   相当于`{}`成为了占位符。
            ```python
            >>> name = '小二'
            >>> '姓名为：{}'.format(name)
            '姓名为：小二'
            ```
-   **f-string**（python3.6以上版本才支持）
    -   语法：`f'{value:w.pf}'`
        -   value：待输出的内容（变量名）
        -   :w\.pf：可选的，w 表示宽度，.pf 针对浮点型表示精度。
            ```python
            >>> height = '80'
            >>> f'体重为{80}kg'
            '体重为80kg'
            ```
#### 5.1.4. 字符串常用内置方法
-   **语法**：`字符串.方法`
    -   `upper()`：将字符串所有的字母转换为大写，返回新字符串。
    -   `lower()`：将字符串所有的字母转换为小写，返回新字符串。
    -   `isupper()`：字符串如果都为大写字母，返回True，否则返回False。
    -   `islower()`：字符串如果都为小写字母，返回True，否则返回False。
    -   `title()`：将字符串所有单词的首字母转换为大写，其余字母小写，返回新字符串。
    -   `count(sub,start,end)`：统计在指定位置之间，子字符串的数量。
        -   start和end都用索引来表示，end取不到。省略不写的话表示从整个字符串寻找。
        -   无该子字符串的话，返回值为0。
    -   `startswith(sub)`：判断字符串是否以指定内容开头，是则返回True,不是则返回False。
    -   `endswith(sub)`：判断字符串是否以指定内容结尾，是则返回True,不是则返回False。
    -   **`strip()`：去除字符串首尾的空字符（包含空格、\t、\n），返回新字符串。**
        -   \t：横向字表符，相当于按了一次tab键。
        -   \n：换行，相当于按了一次回车键。
    -   **`replace(old,new,count)`：将字符串中指定的内容替换为新内容，返回新字符串。**
        -   count：可选的，表示替换的次数（从左往右计数）。省略时表示替换所有的。
        -   如：atm机上名字的显示王五 *，* 中间的字就可以用`**`替换。
    -   `split(sub)`：使用字符串中指定的内容进行分隔，返回一个列表。
        -   sub：可选的，指定用于分隔的内容。省略表示使用空字符（包括空格、\t、\n）分隔。
    -   `join(iter)`：将可迭代对象（字符串，列表，元组，字典）的元素，拼接成字符串。
    -   `center(width,s)`：使用指定内容将字符串补齐到指定长度并居中。
        -   width：长度
        -   s：指定的内容
    -   `isdecimal()`：字符串如果为纯数字，返回True，否则返回False。
    -   `isalpha()`：字符串如果为纯字母，返回True，否则返回False。
    -   `isalnum()`：字符串由字母或者数字组成，返回True，否则返回False。
#### 5.1.5. 字符串的特点
- 有下标(index)，有顺序，可迭代，不可修改
### 5.2. 数值型
-   **整型**：int，整数。不可变数据类型（即不可更改，不像列表等可以修改元素的值）。
-   **浮点型**：float，小数。不可变数据类型。
    -   之所以称为浮点数，是因为按照科学计数法表示时，一个浮点数的小数点位置是可变的。
    -   如：`1.58*10^9` 和 `15.8*10^8` 是相等的。
    -   浮点数可以用数学写法，如`3.14` `-2.5` 等，但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，`1.58*10^9` 等价与`1.58e9` 或`15.8e8` ,0.000005写成`5e-5` 。
    - 整型和浮点型可以做算数运算；浮点型精度比整型高，整型和浮点型做算数运算，结果一定是浮点型。
- **布尔型**：bool，True或False。不可变数据类型。
  - `0`、`False`、`空字符串`、`空列表`、`空字典`、`空元组`以及`None`的布尔值都为`False`,即`bool()`转化后都为`False`;
    - 注：**`None`空值是python里面一个特殊的值，数据类型为`NoneType`**
  - 布尔值在进行可以进行比较和四则运算，True看作1，False看作0
    ```python
    >>> True > False
    True
    >>> True + 1
    2
    >>> False * 3
    0
    ```
-   **复数**：complex，复数由实数部分和虚数部分构成，可以用`a + bj`，或者 `complex(a,b)` 表示，复数的实部a和虚部b都是浮点型。关于复数，不做科学计算或其它特殊需要，通常很难遇到。
    ```python
    >>> a = 10 + 0.2j
    >>> a
    (10+0.2j)
    >>> type(a)
    <class 'complex'>
    >>>
    >>> b = complex(10,0.2)
    >>> b
    (10+0.2j)
    >>> type(b)
    <class 'complex'>
    ```

### 5.3. 列表
#### 5.3.1. 列表的创建
- 包含在`[]`之间的内容，每个元素之间使用逗号隔开，元素可以是任意数据类型。
  - 直接定义列表并填充元素：`li = [1,2,3]`
  - 先创建空列表实例，再添加元素：`li = []`,`li.append(1)`
  - 列表推导式创建：`li = [i for i in range(7)]`
#### 5.3.2. 列表元素的访问
- 访问：通过索引访问指定元素，`列表[索引]`
#### 5.3.3. 列表的内置方法
- 语法：`列表.方法`
- 添加元素：
  - `append(obj)`：将一个对象整体添加到列表末尾;
  - `insert(index,obj)`：将一个对象整体添加到列表指定位置;
  - `extend(iter)`：将一个可迭代对象的每一个元素分别添加到列表中,从末尾开始添加。
- 删除元素：
  - `pop(index)`：删除列表中指定位置的元素，index 是可选的，如果省略表示删除最后一个元素；
  - `remove(obj)`：删除列表中指定的元素。有多个相同的值的话只会删除最左边那个值；
  - `clear()`：清空列表
- 修改元素：
  - 直接使用 `list[index]=value` 的方法替换
- 排序
  - sort(reverse=True,key)：排序。
    - reverse=True：可选的，表示降序排列。省略则表示升序；
    - key：指定排序的内容。
    ```python
    >>> a = [[6,'wl',3],[4,'zo',5],[9,'ok',8],[1,'wi',2]]
    >>> a.sort(reverse=True)
    >>> a
    # 不加key时，默认使用二维列表的0号索引进行排序
    [[9, 'ok', 8], [6, 'wl', 3], [4, 'zo', 5], [1, 'wi', 2]]
    #加key，匿名函数使用二维列表的2号索引进行排序
    >>> a.sort(reverse=True,key=lambda x:x[2])
    >>> a
    [[9, 'ok', 8], [4, 'zo', 5], [6, 'wl', 3], [1, 'wi', 2]]
    ```
  - 反向
    - `reverse()`：将列表中的元素反向
      - reverse 方法是原地反转，作用在原对象上
    - `列表[::-1]`：使用切片方法将列表中的元素反向
      - 切片反转是返回一个新对象，原对象不改变
#### 5.3.4. 列表的特点
- 有下标，有顺序，可迭代，可修改。

### 5.4. 元组
#### 5.4.1. 元组的创建
- 包括在`()`之间的内容，每个元素之间使用逗号隔开，元素可以是任意数据类型。元组为不可变数据类型。
  - 如果元组中只有1个元素，必须在该元素后面加逗号。
  - 也可以不加`()`直接创建元组，如`a = 1,`
  - 使用元组推导式创建：`tup = (i for i in range(7))`
    - 生成的是一个生成器对象，使用for循环遍历或者`tuple()`函数转换为元组来获取元素。遍历或转换后，生成器对象将不复存在。
#### 5.4.2. 元组中元素的访问
- 通过索引访问指定元素。`元组[索引]`。
#### 5.4.3. 元组的内置方法
- 语法：`元组.方法`
- `count(value)`：统计元组中某个元素的数量；
- `index(value)`：查看元组中某个元素的索引。
  - 有多个相同的值时，只能看到最左边的元素的索引
#### 5.4.4. 元组和列表的转换
- 将元组转换位列表
  - `list(元组)`:如a = `(1,2,3)`,`list(a)`
- 将列表转换为元组
  - `tuple(列表)`
#### 5.4.5. 元组的特点
- 有下标，有顺序，可迭代，不可修改。

### 5.5. 字典
#### 5.5.1. 字典的创建
- 包含在`{}`之间的内容，元素以 `key:value` 形式存在，可变数据类型。
  - `key`：在一个字典中，key不能重复，必须为不可变数据类型；
  - `value`：可以为任意数据类型。
  - `dict()`创建空字典实例，再往实例添加元素：`dict1=dict(a='name',b=2,c=3)`
  - `dict()`构造函数可以直接从**键值对序列(有下标的)**里创建字典：`dict1 = dict([('name','wl'),('age',16)])`
    - 二维列表、列表里面套元组或集合都行
  - 列表推导式创建字典：`dict1 = {x**3:x**2 for x in range(7)}`
  - 
#### 5.5.2. 字典的访问
- 元素访问：通过 key 访问指定的键值对。语法：`字典[key]`。若该key不存在，会报错，代码终止。
    - `字典[key] = value`：如果该key存在，则修改该key的值；如果不存在，则新增一对键值对。
#### 5.5.3. 字典的内置方法
- 语法：`字典.方法`
- `get(key)`：返回指定 key 的值。如果key不存在，则返回None（不会报错，代码能继续执行）；
- `setdefault(key,value)`：返回指定 key 的值。如果key不存在，则新增键值对并返回value的值；
- `pop(key)`：删除指定的键值对；
- `clear()`：清空字典；
- `keys()`：以dict_keys 返回字典所有的键。其类型为dict_keys，可通过list()转换为列表；
- `values()`：以dict_values 返回字典所有的值。其类型为dict_values，可通过list()转换为列表；
- `update(key=value,….)`：将指定的key和value添加到字典；
#### 5.5.4. 字典的特点
- 可迭代，可修改，key是唯一且不可变的(整形、字符串、元组)

### 5.6. 集合
#### 5.6.1. 集合的创建
- 一对`{}`括起来的内容，创建的时候，`{}`可以包含有重复的元素，但是创建完后，集合会去重，只保留第一个。
- 使用`set(iter)`创建，传入一个可迭代对象生成集合，当不传入任何参数时，创建空集合。
#### 5.6.2. 集合的内置方法
- 语法：`集合.方法`
- 增加元素
  - `add(obj)`:传入不可修改的对象来增加集合元素。字符串、元组、数值型；
  - `update(iter)`:传入可迭代对象来增加集合元素。集合、列表、元组、字典、字符串。
- 删除元素
  - `remove(value)`：删除指定元素，如果该元素不存在，会报错；
  - `discard()`：如果元素存在则删除，不存在也不会报错；
  - `pop()`：从集合中随机删除元素，和列表、字典不一样，集合使用`pop()`函数不能加任何参数；
  - `clear()`：清空集合
#### 5.6.3. 集合的运算
- `&`：交集,存在集合A并且存在集合B中的元素的集合。也可以使用`set1.intersection(set2)`或`set1.intersection_update(set2)`,后者会直接更新set1，而不是创建一个新的集合对象。
    ```python
    >>> a = {1,2,3}
    >>> b = {2,3,4}
    >>> a & b
    {2, 3}
    ```
- `|`：并集(合集),两个集合进行合并并且去重后的集合。也可以使用`set1.union(set2)`
    ```python
    >>> a = {1,2,3}
    >>> b = {2,3,4}
    >>> a | b
    {1, 2, 3, 4}
    >>> a.union(b)
    {1, 2, 3, 4}
    ```
- `-`：差集,存在于集合A但是不存在于B的元素的集合。也可以用`set1.difference(set2)`
    ```python
    >>> a = {1,2,3}
    >>> b = {2,3,4}
    >>> a - b
    {1}
    >>> b - a
    {4}
    >>> a.difference(b)
    {1}
    >>> b.difference(a)
    {4}
    ```
- `^`：对称集(不重合集),两个集合中不重复的元素的集合。也可以使用`set1.symmetric_difference(set2)`或`set1.symmetric_difference_uodate`,后者或直接更新set1,而不是创建一个新的集合对象。
    ```python
    >>> a = {1,2,3}
    >>> b = {2,3,4}
    >>> a ^ b
    {1, 4}
    ```
#### 5.6.4. 集合的判断
- 判断两集合是否有相同元素：`set1.isdisjoint(set2)`
- 判断是否是子集：`set1.issubset(set2)`
    ```python
    >>> a = {1,2,3}
    >>> b = {2,3}
    >>> b.issubset(a)
    True
    ```
#### 5.6.5. 集合的特点
- 没有顺序，没有下标，不可重复，可变

### 5.7. 数据类型转换
- `bool(obj)`：转换为布尔型(可以将任意类型的数据转化为布尔型)。
  - 注：0、0.0、空字符串、空列表、空元组、空字典、None会转换为False。其他的转换为True。
- `int(obj)`：转换为int型。
  - 注：仅支持布尔型（True-1，False-0）、浮点型（取整数部分）、字符串（纯数字组成，整数（正负都可以）才行，小数不行）。
- `float(obj)`：转换为float型。
  - 注：仅支持布尔型（True-1.0，False-0.0）、整型、字符串（不能包含数字和小数点以外的字符，并且小数点最多只能有1个）。
- `str(obj)`：转换为str型。
  - 任意类型都能转，在待转对象外面加引号。
- `list(lter)`：将可迭代对象转换为列表。
  - 注：字典转为列表是将键取出来放入列表。
### 5.8. 可迭代对象
- 什么是可迭代对象（补充点<a href='#duixiang'> 这里</a>）：
  - 在对象的内置方法中包含`__iter__`方法的为可迭代对象。
  - 可迭代对象：字符串、元组、列表、字典、集合。
- 元素访问：
  - for loop可以遍历可迭代对象的所有元素。（字典遍历的是键）
  - 字符串、元组、列表属于有序序列，可以通过索引访问元素。
  - 字典、集合是无序的。字典通过键访问键值对。
- 切片操作
  - 作用：可以从指定对象返回元素片段。
  - 语法：`bgj[start:end:step]`
    - start：可选的，表示切片开始的位置。如果省略则默认从索引为0的位置开始；
    - end：可选的，表示切片结束的位置（实际取到索引为end-1）。如果省略则表示取到最后一个位置上的元素；
    - step：可选的，表示步长，如果省略则默认步长为1。
    - 注：上述可迭代对象数据类型中字典和集合不能切片（字典和集合是无序序列，没有索引）。 
### 5.9. 常用内建函数(built-in function)
- `eval(str)`：接收一个字符串表达式，并返回表达式的值，
  - 计算字符串中有效的表达式，并返回结果；
  - 将字符串转成相应的对象；
- `len(obj)`：返回可迭代对象中元素的数量。
  - 注：列表里面有子列表，子列表算作一个元素。字典、元组等亦同。
- `del obj`：删除对象。
- sum(iter)：对可迭代对象的元素求和。
## 6. 迭代器
### 6.1. 迭代器的定义
  - 当类中定义了`__inter__`和`__next__`两个方法；
  - `__inter__`方法需要返回对象本身，即`self`；
  - `__next__`方法，返回下一个数据，如果没有数据了，则需要抛出一个StopIteration的异常。
    ```python
    class Ite():
        def __init__(self):
            self.count = 0
        def __iter__(self):
            return self
        def __next__(self):
            self.count += 1
            if self.count == 3:
                raise StopIteration
            return self.count
    ```
    - 以上为一个迭代器类。
### 6.2. 迭代器对象
- 根据迭代器类实例化的对象为迭代器对象。
- 迭代器对象支持通过`next(obj)`方法取值，如果取值结束自动抛出异常StopIteration；
- for循环内部在循环时，先执行`__iter__`方法，获取一个迭代器对象，然后不断执行`next(obj)`方法取值(有异常StopIteration则终止循环)。
    ```python
    # 创建上述迭代器的实例化对象
    # 通过next()方法取值
    obj1 = Ite()
    v1 = next(obj1) # 也就是obj1,__next__()方法
    print(v1)huoqu
    v2 = next(obj1)
    print(v2)
    v3 = next(obj1) # 抛出异常 StopIteration
    print(v3)
    # 通过for循环取值
    obj2 = Ite()
    for i in obj2: # 先执行__iter__方法并获取返回值也就是obj2本身这个迭代器对象，然后反复执行next(obj2),赋值给i直到抛出异常StopIteration结束循环
        print(i)
    ```
### 6.3. <span id='duixiang'>可迭代对象</span>
- 定义：如果一个类中有`__inter__`方法且该方法返回一个迭代器对象，则我们称以这个类创建的对象为可迭代对象。
- - 对比迭代器，可迭代对象只是少了一个`__next__`方法而已。
- 可迭代对象是可以使用for来循环的，在循环的内部其实是先执行`__iter__`方法,然后再在内部执行`next(obj)`，逐步取值的。
  - 所以，凡是能for循环的都是可迭代对象。

## 7. 运算符
### 7.1. python支持的运算符类型
- Python语言支持以下类型的运算符；
- 算术运算符
- 比较（关系）运算符
- 赋值运算符
- 位运算符
- 成员运算符
- 身份运算符
- 逻辑运算符
- 运算符优先级
### 7.2. 算数运算符
- `+` ：返回两个数值型对象的和。
    - 注意：如果参与运算的式两个字符串，则进行字符串拼接操作。如`'a'+'b' = 'ab'`。
- `-`  ：返回两个数值型对象的差。 
- `*` ：返回两个数值型对象的乘积。
    - 注意：如果参与运算的式1个字符串和1个整数，则会将字符串重复n次。如 `'ab'*3 = 'ababab'`
- `/` ：返回两个数值型对象的商。
- `**` ：幂运算。如 `3**4 = 81，4**0.5 = 2.0`
- `//` ：整除，返回小于等于两个数的商的最大整数（向下取整）。如 `5//2=2，5//-2=-3`。
- `%` ：返回两个数相除后的余数，公式：`a%b=a-b*(a//b)`。
### 7.3. 比较运算符
- `==`  `!=`  `>`  `>=`  `<`  `<=`
- 注：包含有比较运算符的表达式叫做布尔表达式，运算结果为`True`或`False`
### 7.4. 赋值运算符
- `=` ：普通的赋值运算符。如 `a = 10`
- `+=` ：如 `a += 1`，相当于`a = a+1`（下同）
- `-=`
- `*=`
- `/=`
- `%=`
- `**=`:如`a **= 3`,相当于`a = a**3`
- `//=`:如`c //= a`,相当于`c = c // a`
### 7.5. 位运算符
- 按位运算符是把十进制的数字看作二进制来进行计算的。Python中的按位运算法则如下：
- `&`：按位与运算符，如果两个相应位都为1，则该位的结果为1，否则为0；
  ```python
    十进制      二进制
    60          0011 1100
    13          0000 1101
    60&13=12    0000 1100
  ```
- `|`：按位或运算符，只要对应的二个二进位有一个为1时，结果位就为1；
- `^`：按位异或运算符，当两对应的二进位相异时，结果为1；
- `~`：按位取反运算符，对数据的每个二进制位取反，即把1变为0，把0变为1；
- `<<`：左移动运算符，把 >> 左边的运算数的各二进位全部右移若干位，>> 右边的数指定移动的位数；
- `>>`：右移动运算符，运算数的各二进位全部左移若干位，由 << 右边的数指定移动的位数，高位丢弃，低位补0。
### 7.6. 成员运算符
- 检查在指定的对象中是否存在指定的内容，存在则返回True，不存在则返回False
    - `in`：如`'a' in {'a':1}` 返回True。检测的是字典的键。
    - `not in`
### 7.7. 身份运算符
- 判断用于比较两个对象的存储单元是否是同一个，即在内存空间中的地址是否是一样的。`id(a) == id(b)`
    - `is`：比较两个对象是同一个或者两个标识符是不是引用自一个对象;
    - `not is`：比较对象不是同一个或者两个标识符是不是引用自不同对象。
### 7.8. 逻辑运算符
- 参与运算符的对象为布尔表达式，运算结果为`True`或`False`;
  - 对于基本类型来说，基本上每个类型都存在一个值被判定为`False`。
    - 整型和浮点型：`0`表示`False`，其他为`True`;
    - 字符串和类字符串类型（包括bytes和Unicode），`空字符串`表示`False`，`非空`为`True`;
    - 序列类型（包括元组，列表，字典，集合等），`空`表示`False`，`非空`表示`True`;
    - None永远表示False。
- `and`：参与运算符的两个表达式都为True，则整体结果为True。只要任意一个表达式结果为False，则整体结果为False；
  - `and`为短路运算符，当左边表达式结果为False，则右边表达式不再运行。
- `or`:参与运算符的两个表达式都为False，则整体结果为False。只要任意一个表达式结果为True，则整体结果为True。
  - `or`为短路运算符，当左边的表达式结果为True，则右边的表达式不再运行。
- `not`：单目运算符，参与运算的表达式结果为True，则整体结果为False；参与运算的表达式结果为False，则整体结果为True。
    - `not A`：判断A是否为0、False、空字符串、空列表、空字典、空元组以及None，满足任一条件即返回True。
    - `A is not None`：判断A是否为None，只要A不是None即返回True。
        - 如：`a = None`  则`a is not None` 返回`False`。因为a是None
        - 如：`b=[]` 则`b is not None` 返回`True`。因为b不是None
- 逻辑运算符运算优先级：`not` > `and` > `or`。
### 7.9. 三元运算符
- 语法：`value1 if 布尔表达式 else value2`，如果布尔表达式结果为True，返回value1，否则返回value2。
    ```python
    s = input("请输入1个字符：")
    print(f"{s}为数字" if s.isdecimal() else (f"{s}为字母" if s.isalpha() else f"{s}为其他字符"))   #注：识别不出中文
    ```

## 8. 控制结构
### 8.1. 分支结构
- **单分支语句**：描述在布尔表达式结果为True的情况下程序要执行的操作。
  ```python
  if 布尔表达式:
    语句1
    语句2
    ...
  ```
- **双分支语句**：描述在布尔表达式结果为True或者False的情况下程序分别要执行的操作。
  ```python
  if 布尔表达式:
    语句1
    语句2
    ...
  else:
    语句1
    语句2
    ...
  ```
  - 布尔表达式结果为True时执行if下面的语句，为False时执行else下面的语句。
- **多分支语句**：描述在多个不同的布尔表达式中，不同结果下分别要执行的操作。
  ```python
  if 布尔表达式1:
    语句1            # 布尔表达式1结果为True时执行
    语句2
    ...
  elif 布尔表达式2:   # 布尔表达式1结果为False时，布尔表达式2结果为True时执行
    语句1
    语句2
    ...
  else:              # 所有的布尔表达式结果为False时执行
    语句1
    语句2
    ...
  ```
- **嵌套分支语句**：在if语句中再写入if语句，可以实现多个不相关条件的判断。
  ```python
  if 布尔表达式1
    if 布尔表达式3:   # 布尔表达式1结果为True时执行此处
      语句3
    else:
      语句4
  else:              # 布尔表达式1结果为False时执行
    语句2
  ```
### 8.2. 循环结构
#### 8.2.1. while
- 语法：
```python
  while 布尔表达式:
    语句1            # 布尔表达式结果为True时执行
    语句2
    ...
  ```
- 循环次数未知时，可以通过声明变量`flag = True`,通过该变量值的变化控制循环继续还是结束。
  ```python
  flag = True
  while flag:
    语句1
    语句2
    ...
    flag = False    # 需要结束循环时，将变量flag的值置为False。
  ```
#### 8.2.2. for
- 语法：
  ```python
  for I in iter:
    语句1
    语句2
    ...
  ```
  - iter：可迭代对象。循环是会依次取可迭代对象中的每一个元素，将这个元素赋值给变量i，直到元素取完为止；
  - i：变量，不需要提前声明，可以在for循环内部直接使用;
  - `range(a,b)`:生成1个`[a,b)`范围内的数字序列。省略a表示从0开始;
  - `for i,j in enumerate(li):`:可以取出列表的索引和值分别赋值给i和j。
  - 例：<span id='cfb'>打印九九乘法表</span>
    ```python
    for i in range(1,10):
      for j in range(1,i+1):    # 当i循环一次时，j也循环一次，实现第一行一列，第二行二列
        print(f"{j}*{i}={i*j:2}",end='\t')
      print('')
    ```
#### 8.2.3. 循环控制语句
  - continue：结束当前这一次循环，开始下一次新的循环；
  - break：终止循环。
#### 8.2.4. 循环语句和else
- 语法：如果循环没有遇到break而终止，则会执行else中的代码。（该else与while或for循环同级，循环完后执行else下的语句）。
  ```python
  while 布尔表达式
    语句1
    语句2
    ...
  else:
    语句n
    ...

  for i in iter:
    语句1
    语句2
    ...
  else:
    语句n
    ...
  ```
- 例：
  ```python
  # [100,200]之间的质数
  li = []
  for i in range(100,201):
  #依次取[2，i-1]范围内的数，如果有任何一个能被i整除，则i不是质数；如果这个范围内所有的数都不能被i整除，则i为质数
    for j in range(2,i):
      if i%j == 0:
        break
    else:
      li.append(i)
  print(set(li))
  ```
### 8.3. 五种推导式
#### 8.3.1. 列表推导式
- 根据指定范围的数据快速生成列表。
- 语法：
  - `[表达式 for i in iter if 布尔表达式]`
  - 判断语句为可选项
#### 8.3.2. 字典推导式
- 根据指定范围的数据快速生成字典。
- 语法：
  - `{key:value for key,value in iter if 布尔表达式}`
  - 判断语句为可选项
  - 例：
  ```python
  # 将列表的偶数索引作为key，对应的值作为value生成字典
  li = ["a","b","c","d","e"]
  dict1 = {key:value for key,value in enumerate(li) if key%2 == 0}
  print(dict1) # {0: 'a', 2: 'c', 4: 'e'}
  ```
#### 8.3.3. 集合推导式
- 根据指定范围的数据快速生成集合。
  - 语法：
    - `{表达式 for i in iter if 布尔表达式}`
    - 判断语句为可选项
#### 8.3.4. 生成器推导式
- 根据指定范围的数据快速生成生成器。
- 语法：
  - `(表达式 for i in iter if 布尔表达式)`
  - 判断语句为可选项
  - 例：
  ```python
  # 将索引为偶数的元素生成一个生成器
  li = ["a","b","c","d","e"]
  gener = (i for i in li if li.index(i)%2 == 0)
  print(type(gener))       # <class 'generator'>
  print(next(gener))       # a
  print(next(gener))       # c
  print(next(gener))       # e
  ```
#### 8.3.5. 嵌套推导式
- 像for循环，if语句等一样，以上所有的推导式都可以多层嵌套。
- 例：使用嵌套推导式来打印上面写的 <a href='#cfb'>九九乘法表</a>
  ```python
  print('\n'.join(['  '.join([f"{j} * {i} = {i * j:2}" for j in range(1, i + 1)]) for i in range(1, 10)]))
  # 拆解
  [[] for i in range(1,10)]
  [[ x for j in range(1,i+1)] for i in range(1,10)]
  [[f"{j} * {i} = {i*j:2}" for j in range(1,i+1)] for i in range(1,10)]
  [[f"{j} * {i} = {i*j:2}" for j in range(1,i+1)] for i in range(1,10)] # 此时打印出来为二维列表
  ['  '.join([f"{j} * {i} = {i*j:2}" for j in range(1,i+1)]) for i in range(1,10)] # 将内层列表用空格拼接为字符串
  '\n'.join(['  '.join([f"{j} * {i} = {i*j:2}" for j in range(1,i+1)]) for i in range(1,10)]) # 将列表用换行符拼接为字符串
  ```

## 9. 函数
### 9.1. 概念
- 函数就是将实现指定功能的代码封装起来，给它起一个名字（函数名），在需要的地方通过这个名字调用（传入相关参数）即可。

### 9.2. 语法
  ```python
  def 函数名(形参1:str,形参2,….):
    语句1
    语句2
    ...
    return value1,value2,...
  ```
- `函数名`：满足标识符的命名规范，通常使用小写的有意义的英文单词。
- `形参1:str,形参2,...`：参数，可选的，在函数的内部可以直接使用这些参数。`形参1:str`，数据类型是可选的，不具有约束的作用，只是做个说明或者提示。
- `return value1,value2,...`：可选的，函数处理完成后通过return语句返回的值，如果省略则默认返回None。函数一旦执行了return语句，则函数就直接结束了。
调用：函数名(实参1,实参2,……)
- `实参1,实参2,...`：可选的，根据函数声明时的实际情况传入实参。

### 9.3. 参数
#### 9.3.1. 形参
- **位置参数**：也叫必须参数，声明时只指定了参数名，要求调用时必须按形参顺序传入实参；
- **默认参数**：声明时通过 key=value 的方式指定该参数的值，调用时该参数传值与否都是正确的；
  - 如果不传入则代码中以声明时指定的那个值为准，如果传入则以实际传入的值为准；
  - **注**:默认参数要放在位置参数和可变参数后面，不能放在前面。
- **可变参数**
  - **可变位置参数**
    - `*args`：接收若干以value传入的实参，将这些值保存在一个元组args中。
      - `args`：为声明元组的变量名，可以修改。如`*num`;
      - 调用函数时如果不传入实参，则args为空元组。
  - **可变关键字参数**
    - `**kwargs`：接收若干 `key=value` 传入的实参，将这些值保存在一个字典中。
      - `kwargs`：为声明字典的变量名，可以修改。如`**num`。
      - 调用函数时如果不传入实参，则kwargs为空字典。
  - **注**：可变位置参数一定要放在可变关键字参数前面。
#### 9.3.2. 实参
- **实参**：调用时实际传入的数据。
  - **普通参数**：以`value`传入，此时传入的值按顺序传递给相应的形参。
  - **关键字参数**，以`key=value`传入，与参数的顺序无关。
    - **注**：如果调用函数时同时存在普通参数和关键字参数，则关键字参数必须放在普通参数后面。

### 9.4. 变量作用域
#### 9.4.1. LEGB
- python的作用域分为4中：
  - `L(Local)`：局部作用域;
  - `E(Enclosing)`：闭包函数外的函数中；
  - `G(Global)`：全局作用域；
  - `B(Built-in)`：内建作用域。
- 变量的查找顺序为：L -> E -> G -> B
  - 即在局部找不到的，就去局部外的局部作用域找(如闭包),在找不到的就去全局作用域找，都找不到就去内建作用域找。
#### 9.4.2. 闭包函数
- 概念：在函数A（外层函数）中声明了一个函数B（内层函数），在函数B中引用函数A的变量，函数A返回函数B的引用（即内层函数名字）。装饰函数很多都是闭包。
#### 9.4.3. 局部和全局作用域
- **局部变量**：在函数内部声明的变量，只能在函数内部使用。
- **全局变量**：在函数外部声明的变量，作用范围是整个脚本（函数内部也可以使用）。
- **注**：函数参数传递的是实际对象的内存地址。如果参数是引用类型的数据类型（列表、字典等），在函数内部修改后，就算没有把修改后的值返回回去，外面的值其实也已经发生了变化。
  ```python
  out_var = [100]    #全局变量
  def f():
    in_var = 200     #局部变量
    out_var[0] = 1000
    """对于out_var这个对象保存在内存空间中的地址没有改变，只是修改变了这个对象里面的某个位置上的值。
    并没有对这个变量重新赋值，而对于不可变数据类型这样修改就是重新赋值，改变了内存空间中的地址"""
    print(out_var[0]+in_var)
  print(out_var)   # [100]
  f()              # 1200
  print(out_var)   # [1000]
  ```

#### 9.4.4. 闭包函数外的作用域
  ```python

  x = 'global'
  def tast():
    x = 'tast'
    print(x)           # tast
    def out_fun():
      nonlocal x       # 为闭包函数外的变量重新赋值
      print(x)         # tast
      x = 'out_var'
      print(x)         # out_var
      def int_fun():
        global x       # 为全局变量重新赋值
        x = 'int_var'
        print(x)       # int_var
      int_fun()
    out_fun()
    print(x)           # out_var

  tast()
  print(x)             # int_var
  ```

#### 9.4.5. 内建作用域
- 内置模块中的变量
  ```python
  from math import e
  def out_fun():
      def int_fun():
          print(e)
          # 2.718281828459045 在L E G作用域都没有变量e，最后找到内内置模块中的e变量
      int_fun()

  out_fun()
  ```

#### 9.4.6. 改变变量的作用域
- **`global`**：在函数内为全局变量重新赋值(将局部变量变为可以作用到全局)。
- **`nonlocal`**：在闭包函数内为闭包函数外的函数中的变量重新赋值(将闭包函数内的变量变为可以作用到闭包函数外)。

### 9.5. 匿名函数
- **匿名函数**（英语：anonymous function）是指一类无需定义标识符（函数名）的函数。通俗来说呢，就是它可以让我们的函数，可以不需要函数名。
- **语法**：`lambda 参数:返回值`,参数为可选项。
- **注**：函数名保存的是这个函数在内存中的地址
  ```python
  def f(n):
    print(n)

  print(f)    # <function f at 0x000002327FAE94C8>
  print(id(f))  # 2415913768136
  t = f   # 将函数名f保存的地址赋值给变量t
  f(2)    # 2
  t(3)    # 3
  ```
- **匿名函数例子**：
  ```python
  # 例1
  p = lambda x:print(x) # 将关键字lambda声明的匿名函数在内存中的地址赋值给变量p
  p(2) # 2 , 调用函数
  # 例2:递归
  p1 = lambda n:1 if n == 0 else n * func(n-1)
  print(p1(5)) # 120
  ```

### 9.6. 常用内建函数(built-in function)
- `map(function,iter)`:传入一个函数和一个可迭代对象，将可迭代对象中的每一个元素作为参数传入函数中，返回一个可迭代对象。











